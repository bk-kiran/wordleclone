{"ast":null,"code":"var _jsxFileName = \"/Users/kirannew/pw/miniapps/wordle/src/App.js\",\n    _s = $RefreshSig$();\n\nimport { useState, useEffect } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function App() {\n  _s();\n\n  const [word, setWord] = useState(\"\");\n  const [error, setError] = useState(\"\");\n  const [loading, setLoading] = useState(true);\n\n  const fetchRandomWord = async function () {\n    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;\n\n    try {\n      setLoading(true);\n      setError(\"\");\n      const res = await fetch(`https://random-word-api.herokuapp.com/word?length=${length}`);\n      const data = await res.json();\n      const w = ((data === null || data === void 0 ? void 0 : data[0]) || \"\").toUpperCase();\n      setWord(w);\n    } catch (e) {\n      setError(\"Failed to fetch word\");\n      console.error(e);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    fetchRandomWord(5); // or 7 for hard mode\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"App\",\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Wordle\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 30,\n      columnNumber: 7\n    }, this), loading && /*#__PURE__*/_jsxDEV(\"p\", {\n      children: \"Loading\\u2026\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 31,\n      columnNumber: 19\n    }, this), error && /*#__PURE__*/_jsxDEV(\"p\", {\n      style: {\n        color: \"red\"\n      },\n      children: error\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 32,\n      columnNumber: 17\n    }, this), !loading && !error && /*#__PURE__*/_jsxDEV(\"p\", {\n      children: [\"Word is: \", word]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 33,\n      columnNumber: 30\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: () => fetchRandomWord(5),\n      children: \"New 5-letter Word\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 35,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: () => fetchRandomWord(7),\n      children: \"New 7-letter Word (Hard)\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 36,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 29,\n    columnNumber: 5\n  }, this);\n}\n/* \n\ndata we need to track:\n  -- solution\n    -- 5 letter string, e.g. 'drain'\n  -- past guesses\n    -- an array of past guesses\n    -- each past guess is an array of letter objects [{}, {}, {}, {}, {}]\n    -- each object represents a letter in the guess word {letter: 'a', color: 'yellow'}\n  -- current guess\n    -- string 'hello'\n  -- keypad letters\n    -- array of letter objects [{key: 'a', color: 'green'}, {}, {} ...]\n  -- number of turns\n    -- an integer 0 - 6\n\ngame process:\n  -- entering words:\n    -- user enters a letter & a square is filled with that letter\n    -- when a user hits delete it deletes the previous letter\n    -- when a user hits enter it submits the word\n      -- if all squares are not filled with letters then the word is not submitted\n      -- if that word has already been used in a prev guess then the word is not submitted\n  -- checking submitted words:\n    -- each letter is checked to see if it matches to the solution\n    -- each letter is assigned a color based on it's inclusion in the solution\n      -- exact matches (correct position in the solution) are green\n      -- partial matches (in the solution but not the correct position) are yellow\n      -- none-matches (not in the solution at all) are grey\n    -- the guess is added the grid with the correct colors\n    -- the current guess moves to the next row\n    -- the keypad letters are updated (colors)\n  -- ending the game:\n    -- when the guessed word fully matches the solution\n      -- modal to say 'well done'\n    -- when the user runs out of guesses\n      -- modal to say 'unlucky'\n\n*/\n\n_s(App, \"ouUavOdr41Nnb5A9UnnZz+3qFTU=\");\n\n_c = App;\n\nvar _c;\n\n$RefreshReg$(_c, \"App\");","map":{"version":3,"sources":["/Users/kirannew/pw/miniapps/wordle/src/App.js"],"names":["useState","useEffect","App","word","setWord","error","setError","loading","setLoading","fetchRandomWord","length","res","fetch","data","json","w","toUpperCase","e","console","color"],"mappings":";;;AAAA,SAASA,QAAT,EAAmBC,SAAnB,QAAoC,OAApC;;AAEA,eAAe,SAASC,GAAT,GAAe;AAAA;;AAC5B,QAAM,CAACC,IAAD,EAAOC,OAAP,IAAkBJ,QAAQ,CAAC,EAAD,CAAhC;AACA,QAAM,CAACK,KAAD,EAAQC,QAAR,IAAoBN,QAAQ,CAAC,EAAD,CAAlC;AACA,QAAM,CAACO,OAAD,EAAUC,UAAV,IAAwBR,QAAQ,CAAC,IAAD,CAAtC;;AAEA,QAAMS,eAAe,GAAG,kBAAsB;AAAA,QAAfC,MAAe,uEAAN,CAAM;;AAC5C,QAAI;AACFF,MAAAA,UAAU,CAAC,IAAD,CAAV;AACAF,MAAAA,QAAQ,CAAC,EAAD,CAAR;AACA,YAAMK,GAAG,GAAG,MAAMC,KAAK,CAAE,qDAAoDF,MAAO,EAA7D,CAAvB;AACA,YAAMG,IAAI,GAAG,MAAMF,GAAG,CAACG,IAAJ,EAAnB;AACA,YAAMC,CAAC,GAAG,CAAC,CAAAF,IAAI,SAAJ,IAAAA,IAAI,WAAJ,YAAAA,IAAI,CAAG,CAAH,CAAJ,KAAa,EAAd,EAAkBG,WAAlB,EAAV;AACAZ,MAAAA,OAAO,CAACW,CAAD,CAAP;AACD,KAPD,CAOE,OAAOE,CAAP,EAAU;AACVX,MAAAA,QAAQ,CAAC,sBAAD,CAAR;AACAY,MAAAA,OAAO,CAACb,KAAR,CAAcY,CAAd;AACD,KAVD,SAUU;AACRT,MAAAA,UAAU,CAAC,KAAD,CAAV;AACD;AACF,GAdD;;AAgBAP,EAAAA,SAAS,CAAC,MAAM;AACdQ,IAAAA,eAAe,CAAC,CAAD,CAAf,CADc,CACM;AACrB,GAFQ,EAEN,EAFM,CAAT;AAIA,sBACE;AAAK,IAAA,SAAS,EAAC,KAAf;AAAA,4BACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YADF,EAEGF,OAAO,iBAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAFd,EAGGF,KAAK,iBAAI;AAAG,MAAA,KAAK,EAAE;AAAEc,QAAAA,KAAK,EAAE;AAAT,OAAV;AAAA,gBAA6Bd;AAA7B;AAAA;AAAA;AAAA;AAAA,YAHZ,EAIG,CAACE,OAAD,IAAY,CAACF,KAAb,iBAAsB;AAAA,8BAAaF,IAAb;AAAA;AAAA;AAAA;AAAA;AAAA,YAJzB,eAME;AAAQ,MAAA,OAAO,EAAE,MAAMM,eAAe,CAAC,CAAD,CAAtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YANF,eAOE;AAAQ,MAAA,OAAO,EAAE,MAAMA,eAAe,CAAC,CAAD,CAAtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAPF;AAAA;AAAA;AAAA;AAAA;AAAA,UADF;AAWD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;GA5EwBP,G;;KAAAA,G","sourcesContent":["import { useState, useEffect } from \"react\";\n\nexport default function App() {\n  const [word, setWord] = useState(\"\");\n  const [error, setError] = useState(\"\");\n  const [loading, setLoading] = useState(true);\n\n  const fetchRandomWord = async (length = 5) => {\n    try {\n      setLoading(true);\n      setError(\"\");\n      const res = await fetch(`https://random-word-api.herokuapp.com/word?length=${length}`);\n      const data = await res.json();\n      const w = (data?.[0] || \"\").toUpperCase();\n      setWord(w);\n    } catch (e) {\n      setError(\"Failed to fetch word\");\n      console.error(e);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    fetchRandomWord(5); // or 7 for hard mode\n  }, []);\n\n  return (\n    <div className=\"App\">\n      <h1>Wordle</h1>\n      {loading && <p>Loadingâ€¦</p>}\n      {error && <p style={{ color: \"red\" }}>{error}</p>}\n      {!loading && !error && <p>Word is: {word}</p>}\n\n      <button onClick={() => fetchRandomWord(5)}>New 5-letter Word</button>\n      <button onClick={() => fetchRandomWord(7)}>New 7-letter Word (Hard)</button>\n    </div>\n  );\n}\n\n/* \n\ndata we need to track:\n  -- solution\n    -- 5 letter string, e.g. 'drain'\n  -- past guesses\n    -- an array of past guesses\n    -- each past guess is an array of letter objects [{}, {}, {}, {}, {}]\n    -- each object represents a letter in the guess word {letter: 'a', color: 'yellow'}\n  -- current guess\n    -- string 'hello'\n  -- keypad letters\n    -- array of letter objects [{key: 'a', color: 'green'}, {}, {} ...]\n  -- number of turns\n    -- an integer 0 - 6\n\ngame process:\n  -- entering words:\n    -- user enters a letter & a square is filled with that letter\n    -- when a user hits delete it deletes the previous letter\n    -- when a user hits enter it submits the word\n      -- if all squares are not filled with letters then the word is not submitted\n      -- if that word has already been used in a prev guess then the word is not submitted\n  -- checking submitted words:\n    -- each letter is checked to see if it matches to the solution\n    -- each letter is assigned a color based on it's inclusion in the solution\n      -- exact matches (correct position in the solution) are green\n      -- partial matches (in the solution but not the correct position) are yellow\n      -- none-matches (not in the solution at all) are grey\n    -- the guess is added the grid with the correct colors\n    -- the current guess moves to the next row\n    -- the keypad letters are updated (colors)\n  -- ending the game:\n    -- when the guessed word fully matches the solution\n      -- modal to say 'well done'\n    -- when the user runs out of guesses\n      -- modal to say 'unlucky'\n\n*/"]},"metadata":{},"sourceType":"module"}