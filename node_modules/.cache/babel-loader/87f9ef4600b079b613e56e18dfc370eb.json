{"ast":null,"code":"var _jsxFileName = \"/Users/kirannew/pw/miniapps/wordle/src/App.js\",\n    _s = $RefreshSig$();\n\nimport { useState, useEffect } from \"react\";\nimport Wordle from \"./components/Wordle\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function App() {\n  _s();\n\n  const [word, setWord] = useState(\"\");\n  const [error, setError] = useState(\"\");\n  const [loading, setLoading] = useState(true);\n  const [length, setLength] = useState(5);\n\n  const STORAGE_KEY = len => `wordle:solution:${len}`;\n\n  const fetchRandomWord = async function () {\n    let len = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : length;\n\n    try {\n      setLoading(true);\n      setError(\"\");\n      const res = await fetch(`https://random-word-api.herokuapp.com/word?length=${len}`);\n      const data = await res.json();\n      const w = ((data === null || data === void 0 ? void 0 : data[0]) || \"\").toUpperCase();\n      setWord(w);\n      localStorage.setItem(STORAGE_KEY(len), w); // persist\n    } catch (e) {\n      setError(\"Failed to fetch word\");\n      console.error(e);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    const saved = localStorage.getItem(STORAGE_KEY(length));\n\n    if (saved) {\n      setWord(saved);\n      setLoading(false);\n    } else {\n      fetchRandomWord(length);\n    }\n  }, [setWord, length]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"App\",\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Wordle\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 41,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: () => setLength(5),\n      children: \"Normal (5)\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 43,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: () => setLength(7),\n      children: \"Hard (7)\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 44,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: () => {\n        localStorage.removeItem(`wordle:solution:${length}`);\n        fetchRandomWord(length);\n      },\n      children: \"New Word\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 46,\n      columnNumber: 9\n    }, this), word && /*#__PURE__*/_jsxDEV(Wordle, {\n      solution: word\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 55,\n      columnNumber: 18\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 40,\n    columnNumber: 5\n  }, this);\n}\n/* \n\ndata we need to track:\n  -- solution\n    -- 5 letter string, e.g. 'drain'\n  -- past guesses\n    -- an array of past guesses\n    -- each past guess is an array of letter objects [{}, {}, {}, {}, {}]\n    -- each object represents a letter in the guess word {letter: 'a', color: 'yellow'}\n  -- current guess\n    -- string 'hello'\n  -- keypad letters\n    -- array of letter objects [{key: 'a', color: 'green'}, {}, {} ...]\n  -- number of turns\n    -- an integer 0 - 6\n\ngame process:\n  -- entering words:\n    -- user enters a letter & a square is filled with that letter\n    -- when a user hits delete it deletes the previous letter\n    -- when a user hits enter it submits the word\n      -- if all squares are not filled with letters then the word is not submitted\n      -- if that word has already been used in a prev guess then the word is not submitted\n  -- checking submitted words:\n    -- each letter is checked to see if it matches to the solution\n    -- each letter is assigned a color based on it's inclusion in the solution\n      -- exact matches (correct position in the solution) are green\n      -- partial matches (in the solution but not the correct position) are yellow\n      -- none-matches (not in the solution at all) are grey\n    -- the guess is added the grid with the correct colors\n    -- the current guess moves to the next row\n    -- the keypad letters are updated (colors)\n  -- ending the game:\n    -- when the guessed word fully matches the solution\n      -- modal to say 'well done'\n    -- when the user runs out of guesses\n      -- modal to say 'unlucky'\n\n*/\n\n_s(App, \"RxYJfpN/fBEPSDHwtc6zkiDBWCs=\");\n\n_c = App;\n\nvar _c;\n\n$RefreshReg$(_c, \"App\");","map":{"version":3,"sources":["/Users/kirannew/pw/miniapps/wordle/src/App.js"],"names":["useState","useEffect","Wordle","App","word","setWord","error","setError","loading","setLoading","length","setLength","STORAGE_KEY","len","fetchRandomWord","res","fetch","data","json","w","toUpperCase","localStorage","setItem","e","console","saved","getItem","removeItem"],"mappings":"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","sourcesContent":["import { useState, useEffect } from \"react\";\nimport Wordle from \"./components/Wordle\";\n\nexport default function App() {\n  const [word, setWord] = useState(\"\");\n  const [error, setError] = useState(\"\");\n  const [loading, setLoading] = useState(true);\n  const [length, setLength] = useState(5); \n\n  const STORAGE_KEY = (len) => `wordle:solution:${len}`;\n\n  const fetchRandomWord = async (len = length) => {\n    try {\n      setLoading(true);\n      setError(\"\");\n      const res = await fetch(`https://random-word-api.herokuapp.com/word?length=${len}`);\n      const data = await res.json();\n      const w = (data?.[0] || \"\").toUpperCase();\n      setWord(w);\n      localStorage.setItem(STORAGE_KEY(len), w); // persist\n    } catch (e) {\n      setError(\"Failed to fetch word\");\n      console.error(e);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    const saved = localStorage.getItem(STORAGE_KEY(length));\n    if (saved) {\n      setWord(saved);\n      setLoading(false);\n    } else {\n      fetchRandomWord(length);\n    }\n  }, [setWord, length]); \n\n  return (\n    <div className=\"App\">\n      <h1>Wordle</h1>\n\n        <button onClick={() => setLength(5)}>Normal (5)</button>\n        <button onClick={() => setLength(7)}>Hard (7)</button>\n\n        <button\n          onClick={() => {\n            localStorage.removeItem(`wordle:solution:${length}`);\n            fetchRandomWord(length);\n          }}\n        >\n          New Word\n        </button>\n\n        {word && <Wordle solution={word} />}\n    </div>\n  );\n}\n\n/* \n\ndata we need to track:\n  -- solution\n    -- 5 letter string, e.g. 'drain'\n  -- past guesses\n    -- an array of past guesses\n    -- each past guess is an array of letter objects [{}, {}, {}, {}, {}]\n    -- each object represents a letter in the guess word {letter: 'a', color: 'yellow'}\n  -- current guess\n    -- string 'hello'\n  -- keypad letters\n    -- array of letter objects [{key: 'a', color: 'green'}, {}, {} ...]\n  -- number of turns\n    -- an integer 0 - 6\n\ngame process:\n  -- entering words:\n    -- user enters a letter & a square is filled with that letter\n    -- when a user hits delete it deletes the previous letter\n    -- when a user hits enter it submits the word\n      -- if all squares are not filled with letters then the word is not submitted\n      -- if that word has already been used in a prev guess then the word is not submitted\n  -- checking submitted words:\n    -- each letter is checked to see if it matches to the solution\n    -- each letter is assigned a color based on it's inclusion in the solution\n      -- exact matches (correct position in the solution) are green\n      -- partial matches (in the solution but not the correct position) are yellow\n      -- none-matches (not in the solution at all) are grey\n    -- the guess is added the grid with the correct colors\n    -- the current guess moves to the next row\n    -- the keypad letters are updated (colors)\n  -- ending the game:\n    -- when the guessed word fully matches the solution\n      -- modal to say 'well done'\n    -- when the user runs out of guesses\n      -- modal to say 'unlucky'\n\n*/"]},"metadata":{},"sourceType":"module"}