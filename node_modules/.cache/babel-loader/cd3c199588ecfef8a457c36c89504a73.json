{"ast":null,"code":"var _jsxFileName = \"/Users/kirannew/pw/miniapps/wordle/src/App.js\",\n    _s = $RefreshSig$();\n\nimport { useState, useEffect } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function App() {\n  _s();\n\n  const [word, setWord] = useState(\"\");\n  const [error, setError] = useState(\"\");\n  const [loading, setLoading] = useState(true);\n  const [length, setLength] = useState(5); // 5 = normal, 7 = hard\n\n  const STORAGE_KEY = len => `wordle:solution:${len}`;\n\n  const fetchRandomWord = async function () {\n    let len = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : length;\n\n    try {\n      setLoading(true);\n      setError(\"\");\n      const res = await fetch(`https://random-word-api.herokuapp.com/word?length=${len}`);\n      const data = await res.json();\n      const w = ((data === null || data === void 0 ? void 0 : data[0]) || \"\").toUpperCase();\n      setWord(w);\n      localStorage.setItem(STORAGE_KEY(len), w); // persist\n    } catch (e) {\n      setError(\"Failed to fetch word\");\n      console.error(e);\n    } finally {\n      setLoading(false);\n    }\n  }; // On mount & whenever mode/length changes: try to load from storage; if none, fetch.\n\n\n  useEffect(() => {\n    const saved = localStorage.getItem(STORAGE_KEY(length));\n\n    if (saved) {\n      setWord(saved);\n      setLoading(false);\n    } else {\n      fetchRandomWord(length);\n    }\n  }, [length]); // runs again when you switch modes\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"App\",\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Wordle\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 41,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        display: \"flex\",\n        gap: 8,\n        marginBottom: 12\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => setLength(5),\n        disabled: length === 5,\n        \"aria-pressed\": length === 5,\n        children: \"Normal (5)\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 44,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => setLength(7),\n        disabled: length === 7,\n        \"aria-pressed\": length === 7,\n        children: \"Hard (7)\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 51,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 43,\n      columnNumber: 7\n    }, this), loading && /*#__PURE__*/_jsxDEV(\"p\", {\n      children: \"Loading\\u2026\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 60,\n      columnNumber: 19\n    }, this), error && /*#__PURE__*/_jsxDEV(\"p\", {\n      style: {\n        color: \"red\"\n      },\n      children: error\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 61,\n      columnNumber: 17\n    }, this), !loading && !error && /*#__PURE__*/_jsxDEV(\"p\", {\n      children: [\"Word is: \", word]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 62,\n      columnNumber: 30\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: () => fetchRandomWord(5),\n      children: \"New 5-letter Word\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 64,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: () => fetchRandomWord(7),\n      children: \"New 7-letter Word\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 65,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: () => {\n        localStorage.removeItem(STORAGE_KEY(length)); // forget current word for this mode\n\n        fetchRandomWord(length); // force a fresh one\n      },\n      children: \"Reset Current Mode\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 66,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 40,\n    columnNumber: 5\n  }, this);\n}\n/* \n\ndata we need to track:\n  -- solution\n    -- 5 letter string, e.g. 'drain'\n  -- past guesses\n    -- an array of past guesses\n    -- each past guess is an array of letter objects [{}, {}, {}, {}, {}]\n    -- each object represents a letter in the guess word {letter: 'a', color: 'yellow'}\n  -- current guess\n    -- string 'hello'\n  -- keypad letters\n    -- array of letter objects [{key: 'a', color: 'green'}, {}, {} ...]\n  -- number of turns\n    -- an integer 0 - 6\n\ngame process:\n  -- entering words:\n    -- user enters a letter & a square is filled with that letter\n    -- when a user hits delete it deletes the previous letter\n    -- when a user hits enter it submits the word\n      -- if all squares are not filled with letters then the word is not submitted\n      -- if that word has already been used in a prev guess then the word is not submitted\n  -- checking submitted words:\n    -- each letter is checked to see if it matches to the solution\n    -- each letter is assigned a color based on it's inclusion in the solution\n      -- exact matches (correct position in the solution) are green\n      -- partial matches (in the solution but not the correct position) are yellow\n      -- none-matches (not in the solution at all) are grey\n    -- the guess is added the grid with the correct colors\n    -- the current guess moves to the next row\n    -- the keypad letters are updated (colors)\n  -- ending the game:\n    -- when the guessed word fully matches the solution\n      -- modal to say 'well done'\n    -- when the user runs out of guesses\n      -- modal to say 'unlucky'\n\n*/\n\n_s(App, \"RxYJfpN/fBEPSDHwtc6zkiDBWCs=\");\n\n_c = App;\n\nvar _c;\n\n$RefreshReg$(_c, \"App\");","map":{"version":3,"sources":["/Users/kirannew/pw/miniapps/wordle/src/App.js"],"names":["useState","useEffect","App","word","setWord","error","setError","loading","setLoading","length","setLength","STORAGE_KEY","len","fetchRandomWord","res","fetch","data","json","w","toUpperCase","localStorage","setItem","e","console","saved","getItem","display","gap","marginBottom","color","removeItem"],"mappings":"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","sourcesContent":["import { useState, useEffect } from \"react\";\n\nexport default function App() {\n  const [word, setWord] = useState(\"\");\n  const [error, setError] = useState(\"\");\n  const [loading, setLoading] = useState(true);\n  const [length, setLength] = useState(5); // 5 = normal, 7 = hard\n\n  const STORAGE_KEY = (len) => `wordle:solution:${len}`;\n\n  const fetchRandomWord = async (len = length) => {\n    try {\n      setLoading(true);\n      setError(\"\");\n      const res = await fetch(`https://random-word-api.herokuapp.com/word?length=${len}`);\n      const data = await res.json();\n      const w = (data?.[0] || \"\").toUpperCase();\n      setWord(w);\n      localStorage.setItem(STORAGE_KEY(len), w); // persist\n    } catch (e) {\n      setError(\"Failed to fetch word\");\n      console.error(e);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // On mount & whenever mode/length changes: try to load from storage; if none, fetch.\n  useEffect(() => {\n    const saved = localStorage.getItem(STORAGE_KEY(length));\n    if (saved) {\n      setWord(saved);\n      setLoading(false);\n    } else {\n      fetchRandomWord(length);\n    }\n  }, [length]); // runs again when you switch modes\n\n  return (\n    <div className=\"App\">\n      <h1>Wordle</h1>\n\n      <div style={{ display: \"flex\", gap: 8, marginBottom: 12 }}>\n        <button\n          onClick={() => setLength(5)}\n          disabled={length === 5}\n          aria-pressed={length === 5}\n        >\n          Normal (5)\n        </button>\n        <button\n          onClick={() => setLength(7)}\n          disabled={length === 7}\n          aria-pressed={length === 7}\n        >\n          Hard (7)\n        </button>\n      </div>\n\n      {loading && <p>Loadingâ€¦</p>}\n      {error && <p style={{ color: \"red\" }}>{error}</p>}\n      {!loading && !error && <p>Word is: {word}</p>}\n\n      <button onClick={() => fetchRandomWord(5)}>New 5-letter Word</button>\n      <button onClick={() => fetchRandomWord(7)}>New 7-letter Word</button>\n      <button\n        onClick={() => {\n          localStorage.removeItem(STORAGE_KEY(length)); // forget current word for this mode\n          fetchRandomWord(length); // force a fresh one\n        }}\n      >\n        Reset Current Mode\n      </button>\n    </div>\n  );\n}\n\n/* \n\ndata we need to track:\n  -- solution\n    -- 5 letter string, e.g. 'drain'\n  -- past guesses\n    -- an array of past guesses\n    -- each past guess is an array of letter objects [{}, {}, {}, {}, {}]\n    -- each object represents a letter in the guess word {letter: 'a', color: 'yellow'}\n  -- current guess\n    -- string 'hello'\n  -- keypad letters\n    -- array of letter objects [{key: 'a', color: 'green'}, {}, {} ...]\n  -- number of turns\n    -- an integer 0 - 6\n\ngame process:\n  -- entering words:\n    -- user enters a letter & a square is filled with that letter\n    -- when a user hits delete it deletes the previous letter\n    -- when a user hits enter it submits the word\n      -- if all squares are not filled with letters then the word is not submitted\n      -- if that word has already been used in a prev guess then the word is not submitted\n  -- checking submitted words:\n    -- each letter is checked to see if it matches to the solution\n    -- each letter is assigned a color based on it's inclusion in the solution\n      -- exact matches (correct position in the solution) are green\n      -- partial matches (in the solution but not the correct position) are yellow\n      -- none-matches (not in the solution at all) are grey\n    -- the guess is added the grid with the correct colors\n    -- the current guess moves to the next row\n    -- the keypad letters are updated (colors)\n  -- ending the game:\n    -- when the guessed word fully matches the solution\n      -- modal to say 'well done'\n    -- when the user runs out of guesses\n      -- modal to say 'unlucky'\n\n*/"]},"metadata":{},"sourceType":"module"}